-- alpus_wb32_all.vhd is generated by build.sh from individual files

-- alpus_wb32_pkg - package for 32-bit Wishbone bus signalling
--
-- slave select functions for easy slave selection, DOES NOT support addressing multiple slaves within one cycle
--

library ieee;
use ieee.std_logic_1164.all;

package alpus_wb32_pkg is
	constant alpus_wb_awid : integer := 32;

	-- Wishbone signals to slave direction
	type alpus_wb32_tos_t is record
		cyc    : std_logic; -- bus cycle
		we     : std_logic; -- wr cycle (rd_n)
		stb    : std_logic; -- transfer cycle, slave select
		adr    : std_logic_vector(alpus_wb_awid-1 downto 0); -- BYTE address
		data   : std_logic_vector(31 downto 0);
		sel    : std_logic_vector(3 downto 0); -- write enable
		--tgd    : std_logic;
		--tga    : std_logic;
		--tgc    : std_logic;
		--lock    : std_logic;
	end record alpus_wb32_tos_t;  
  
	-- Wishbone signals to master direction
	type alpus_wb32_tom_t is record
		data  : std_logic_vector(31 downto 0);
		stall : std_logic;
		ack    : std_logic; -- bus cycle ack
		--tgd    : std_logic;
		--err    : std_logic; -- bus cycle nack
		--rty    : std_logic; -- bus cycle ->retry
	end record alpus_wb32_tom_t;  

	type alpus_wb32_tos_array_t is array (integer range <>) of alpus_wb32_tos_t;
	type alpus_wb32_tom_array_t is array (integer range <>) of alpus_wb32_tom_t;
	
	-- Initial/idle values
	constant alpus_wb32_tos_init : alpus_wb32_tos_t := ('0', '0', '0', (others => '0'), (others => '0'), (others => '0'));
	constant alpus_wb32_tom_init : alpus_wb32_tom_t := ((others => '0'), '0', '0');

	-- Select slave by address and mask
	function alpus_wb32_slave_select_tos(
		adr  : std_logic_vector(alpus_wb_awid-1 downto 0);
		mask : std_logic_vector(alpus_wb_awid-1 downto 0);
		m : alpus_wb32_tos_t
	) return alpus_wb32_tos_t;

	function alpus_wb32_slave_select_tom(
		adr  : std_logic_vector(alpus_wb_awid-1 downto 0); --addr for A
		mask : std_logic_vector(alpus_wb_awid-1 downto 0);
		m : alpus_wb32_tos_t;
		a : alpus_wb32_tom_t;
		b : alpus_wb32_tom_t
	) return alpus_wb32_tom_t;

	component alpus_wb32_master_select is
	generic(
		NUM_MASTERS : integer := 2
	);
	port(
		clk : in std_logic;
		rst : in std_logic;

		master_side_tos : in alpus_wb32_tos_array_t(0 to NUM_MASTERS-1);
		master_side_tom : out alpus_wb32_tom_array_t(0 to NUM_MASTERS-1);
		slave_side_tos : out alpus_wb32_tos_t;
		slave_side_tom : in alpus_wb32_tom_t
	);
	end component;

	component alpus_wb32_pipeline_bridge is
	generic(
		REG_REQUEST : std_logic := '0';
		REG_STALL : std_logic := '1';
		REG_RESPONSE : std_logic := '0'
	);
	port(
		clk : in std_logic;
		rst : in std_logic;

		master_side_tos : in alpus_wb32_tos_t;
		master_side_tom : out alpus_wb32_tom_t;
		slave_side_tos : out alpus_wb32_tos_t;
		slave_side_tom : in alpus_wb32_tom_t
	);
	end component;

end package;

package body alpus_wb32_pkg is

	function alpus_wb32_slave_select_tos(
		adr  : std_logic_vector(alpus_wb_awid-1 downto 0);
		mask : std_logic_vector(alpus_wb_awid-1 downto 0);
		m : alpus_wb32_tos_t
	) return alpus_wb32_tos_t is
		variable RET : alpus_wb32_tos_t;
	begin
		if (adr and mask) = (m.adr and mask) then
			return m;
		else
			RET := m;
			RET.cyc := '0';
			RET.we := '0'; --not needed but prettier in simulation
			RET.stb := '0';
			return RET;
		end if;
	end function;

	function alpus_wb32_slave_select_tom(
		adr  : std_logic_vector(alpus_wb_awid-1 downto 0);
		mask : std_logic_vector(alpus_wb_awid-1 downto 0);
		m : alpus_wb32_tos_t;
		a : alpus_wb32_tom_t;
		b : alpus_wb32_tom_t
	) return alpus_wb32_tom_t is
	begin
		if (adr and mask) = (m.adr and mask) then
			return a;
		else
			return b;
		end if;
	end function;

end;
-- alpus_wb_master_select 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.alpus_wb32_pkg.all;

entity alpus_wb32_master_select is
generic(
	NUM_MASTERS : integer := 3
);
port(
	clk : in std_logic;
	rst : in std_logic;

	master_side_tos : in alpus_wb32_tos_array_t(0 to NUM_MASTERS-1);
	master_side_tom : out alpus_wb32_tom_array_t(0 to NUM_MASTERS-1);
	slave_side_tos : out alpus_wb32_tos_t;
	slave_side_tom : in alpus_wb32_tom_t
);
end entity alpus_wb32_master_select;

architecture rtl of alpus_wb32_master_select is

	signal arbit_request : std_logic;
	signal arbit_candidate : integer range 0 to NUM_MASTERS-1;
	
	type arbit_fsm_t is (wait_for_request, wait_for_request_ending);
	signal arbit_fsm : arbit_fsm_t;
	signal arbit_request_held : std_logic;
	signal arbit_chosen : integer range 0 to NUM_MASTERS-1;

begin

	process(master_side_tos)
	begin
		arbit_request <= '0';
		arbit_candidate <= 0;
		-- priority arbiter TODO sequential round-robin
		for i in NUM_MASTERS-1 downto 0 loop
			if master_side_tos(i).cyc = '1' then
				arbit_request <= '1';
				arbit_candidate <= i;
			end if;
		end loop;
	end process;

	process(clk)
	begin
		if rising_edge(clk) then
		
			case arbit_fsm is
			when wait_for_request =>
				if arbit_request = '1' then
					arbit_chosen <= arbit_candidate;
					arbit_fsm <= wait_for_request_ending;
				end if;
			when others =>
				if master_side_tos(arbit_chosen).cyc = '0' then
					arbit_fsm <= wait_for_request;
				end if;
			end case;
			
			if rst = '1' then
				arbit_fsm <= wait_for_request;
			end if;
		end if;
	end process;
	
	process(master_side_tos, slave_side_tom, arbit_candidate, arbit_chosen, arbit_fsm)
		variable arbit_chosen_v : integer range 0 to NUM_MASTERS-1;
	begin
		
		if arbit_fsm = wait_for_request_ending then
			arbit_chosen_v := arbit_chosen;
		else
			arbit_chosen_v := arbit_candidate;
		end if;

		slave_side_tos <= master_side_tos(arbit_chosen_v);
		if arbit_fsm = wait_for_request_ending and master_side_tos(arbit_chosen_v).cyc = '0' then
			slave_side_tos.cyc <= '0';
		end if;

		for i in 0 to NUM_MASTERS-1 loop
			if i = arbit_chosen_v then
				master_side_tom(i) <= slave_side_tom;
			else
				master_side_tom(i) <= alpus_wb32_tom_init;
				master_side_tom(i).stall <= '1';
			end if;
			master_side_tom(i).data <= slave_side_tom.data; -- save logic: no clear data
		end loop;

	end process;

end;-- alpus_wb_pipeline_bridge 
--
-- Unbuffered pipeline bridge. Stall is often the critical path, but registering it causes wait states.
-- 1. Keep master stalled by default
-- 2. Whenever master has stb, give unregistered stb to slave
-- 3. If slave was not stalled on clock edge, give registered stall='0' tp master
-- 4. Master can give another stb
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library work;
use work.alpus_wb32_pkg.all;

entity alpus_wb32_pipeline_bridge is
generic(
	REG_REQUEST : std_logic := '0';
	REG_STALL : std_logic := '1';
	REG_RESPONSE : std_logic := '0'
);
port(
	clk : in std_logic;
	rst : in std_logic;

	master_side_tos : in alpus_wb32_tos_t;
	master_side_tom : out alpus_wb32_tom_t;
	slave_side_tos : out alpus_wb32_tos_t;
	slave_side_tom : in alpus_wb32_tom_t
);
end entity alpus_wb32_pipeline_bridge;

architecture rtl of alpus_wb32_pipeline_bridge is
	
	signal slave_side_tos_i : alpus_wb32_tos_t;
	signal master_side_tom_i : alpus_wb32_tom_t;

	type request_fsm_t is (idle, request);
	signal request_fsm : request_fsm_t;

	type stall_fsm_t is (stall_master, unstall_master, request);
	signal stall_fsm : stall_fsm_t;

begin
	-- TODO: either REG_REQUEST or REG_RESPONSE should be active when REG_STALL = '1' to avoid zero or less ack latency

	--
	-- Request direction registering
	--
	process(clk, master_side_tos, master_side_tom_i, request_fsm)
	begin
		if REG_REQUEST = '0' then
			slave_side_tos_i <= master_side_tos;
		end if;		

		if rising_edge(clk) then
			if REG_REQUEST = '1' then
				case request_fsm is
				when idle =>
					if master_side_tos.cyc = '1' then -- and stb?
						slave_side_tos_i <= master_side_tos;
						request_fsm <= request;
					else
						slave_side_tos_i <= alpus_wb32_tos_init;
					end if;
				when others =>
					if master_side_tos.cyc = '1' then
						if master_side_tom_i.stall = '0' then
							slave_side_tos_i <= master_side_tos;
						end if;
					else
						slave_side_tos_i <= alpus_wb32_tos_init;
						request_fsm <= idle;
					end if;
				end case;
			end if;

			if rst = '1' then
				request_fsm <= idle;
			end if;
		end if; -- clk

		master_side_tom <= master_side_tom_i;
		if REG_REQUEST = '1' then
			if request_fsm = idle then
				master_side_tom.stall <= '0';
			else
				master_side_tom.stall <= master_side_tom_i.stall;
			end if;
		else
			master_side_tom.stall <= master_side_tom_i.stall;
		end if;
	end process;

	--
	-- Response/Stall direction registering
	--
	process(clk, slave_side_tos_i, slave_side_tom, stall_fsm)
	begin
		if REG_STALL = '1' then
			slave_side_tos <= slave_side_tos_i;
			if stall_fsm = unstall_master then
				slave_side_tos.stb <= '0';
			end if;
		else
			slave_side_tos <= slave_side_tos_i;
		end if;

		if rising_edge(clk) then
			if REG_STALL = '1' then
				case stall_fsm is
				when stall_master =>
					if slave_side_tos_i.cyc = '1' and slave_side_tos_i.stb = '1' and slave_side_tom.stall = '0' then
						master_side_tom_i.stall <= '0';
						stall_fsm <= unstall_master;
					else
						master_side_tom_i.stall <= '1';
					end if;
				when others =>
					master_side_tom_i.stall <= '1';
					stall_fsm <= stall_master;
				end case;
			end if;

			if REG_RESPONSE = '1' then
				master_side_tom_i.data <= slave_side_tom.data;
				master_side_tom_i.ack <= slave_side_tom.ack;
			end if;

			if rst = '1' then
				stall_fsm <= stall_master;
			end if;
		end if; -- clk

		if REG_RESPONSE = '0' then
			master_side_tom_i.data <= slave_side_tom.data;
			master_side_tom_i.ack <= slave_side_tom.ack;
		end if;
		if REG_STALL = '0' then
			master_side_tom_i.stall <= slave_side_tom.stall;
		end if;
	end process;
end;